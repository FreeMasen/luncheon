==============================================================================
luncheon/headers.lua
==============================================================================

      ---@class Headers
      ---A map of the key value pairs from the header portion
      ---of an HTTP request
      ---@field public accept string
      ---@field public accept_charset string
      ---@field public accept_encoding string
      ---@field public accept_language string
      ---@field public accept_ranges string
      ---@field public age string
      ---@field public allow string
      ---@field public authorization string
      ---@field public cache_control string
      ---@field public connection string
      ---@field public content_encoding string
      ---@field public content_language string
      ---@field public content_length string
      ---@field public content_location string
      ---@field public content_md5 string
      ---@field public content_range string
      ---@field public content_type string
      ---@field public date string
      ---@field public etag string
      ---@field public expect string
      ---@field public expires string
      ---@field public from string
      ---@field public host string
      ---@field public if_match string
      ---@field public if_modified_since string
      ---@field public if_none_match string
      ---@field public if_range string
      ---@field public if_unmodified_since string
      ---@field public last_modified string
      ---@field public location string
      ---@field public max_forwards string
      ---@field public pragma string
      ---@field public proxy_authenticate string
      ---@field public proxy_authorization string
      ---@field public range string
      ---@field public referer string
      ---@field public retry_after string
      ---@field public server string
      ---@field public te string
      ---@field public trailer string
      ---@field public upgrade string
      ---@field public user_agent string
      ---@field public vary string
      ---@field public via string
      ---@field public warning string
      ---@field public www_authenticate string
    3 local Headers = {}

    3 Headers.__index = Headers

      local function _append(t, key, value)
  106     if not t[key] then
  101         t[key] = value
    5     elseif type(t[key]) == 'string' then
    4         t[key] = {t[key], value}
          else
    1         table.insert(t[key], value)
          end
      end

      ---Serialize a key value pair
      ---@param key string
      ---@param value string
      ---@return string
      local function serialize_header(key, value)
   58     if type(value) == 'table' then
    2         value = value[#value]
          end
          -- special case for MD5
   58     key = string.gsub(key, 'md5', 'mD5')
          -- special case for ETag
   58     key = string.gsub(key, 'etag', 'ETag')
   58     if #key < 3 then
    1         return string.format('%s: %s', key:upper(), value)
          end
          -- special case for WWW-*
   57     key = string.gsub(key, 'www', 'WWW')
  114     local replaced = key:sub(1, 1):upper() .. string.gsub(key:sub(2), '_(%l)', function (c)
   37         return '-' .. c:upper()
          end)
   57     return string.format('%s: %s', replaced, value)
      end

      ---Serialize the whole set of headers seperating them with a '\r\n'
      ---@return string
    3 function Headers:serialize()
   11     local ret = ''
   21     for key, value in pairs(self) do
   10         if key ~= 'last_key' then
   10             ret = ret .. serialize_header(key, value) .. '\r\n'
              end
          end
   11     return ret
      end

      ---Append a chunk of headers to this map
      ---@param text string
    3 function Headers:append_chunk(text)
   99     if string.match(text, '^%s+') ~= nil then
    2         if not self.last_key then
****0             return nil, 'Header continuation with no key'
              end
    2         local existing = self[self.last_key]
    2         self[self.last_key] = string.format('%s %s', existing, text)
    2         return 1
          end
  194     for raw_key, value in string.gmatch(text, '([0-9a-zA-Z\\-]+): (.+);?') do
   97         local key = Headers.normalize_key(raw_key)
   97         self:append(key, value)
          end
   97     return 1
      end

      ---Constructor for a Headers instance with the provided text
      ---@param text string
      ---@return Headers
    3 function Headers.from_chunk(text)
    1     local headers = Headers.new()
    1     headers:append_chunk(text)
    1     return headers
      end

      ---Bare constructor
      ---@param base table|nil
    3 function Headers.new(base)
   28     local ret = base or {
   28         last_key = nil,
          }
   28     setmetatable(ret, Headers)
   28     return ret
      end

      ---Convert a standard header key to the normalized
      ---lua identifer used by this collection
      ---@param key string
      ---@return string
    3 function Headers.normalize_key(key)
  103     local lower = string.lower(key)
  103     local normalized = string.gsub(lower, '-', '_')
  103     return normalized
      end

      ---Insert a single key value pair to the collection
    3 function Headers:append(key, value)
  106     _append(self, key, value)
  106     self.last_key = key
      end

      ---Get a header from the map of headers
      ---
      ---This will first normalize the provided key. For example
      ---'Content-Type' will be normalized to `content_type`.
      ---If more than one value is provided for that header, the
      ---last value will be provided
      ---@param key string
      ---@return string
    3 function Headers:get_one(key)
    4     local k = Headers.normalize_key(key or '')
    4     local value = self[k]
    4     if type(value) == 'table' then
    2         return value[#value]
          else
    2         return value
          end
      end

      ---Get a header from the map of headers
      ---
      ---This will first normalize the provided key. For example
      ---'Content-Type' will be normalized to `content_type`.
      ---If more than one value is provided for that header
      ---@param key string
      ---@return string[]
    3 function Headers:get_all(key)
    2     local k = Headers.normalize_key(key or '')
    2     local values = self[k]
    2     if type(values) == 'string' then
    1         return {values}
          end
    1     return self[k]
      end

    3 return {
    3     Headers = Headers,
    3     serialize_header = serialize_header,
    3 }

==============================================================================
luncheon/request.lua
==============================================================================
    1 local net_url = require 'net.url'
    1 local Headers = require 'luncheon.headers'.Headers

      ---@class Request
      ---@field public method string the HTTP method for this request
      ---@field public url table The parse url of this request
      ---@field public http_version string The http version from the request preamble
      ---@field public headers Headers The HTTP headers for this request
      ---@field public body string The contents of the request
      ---@field private err string|nil The _last_ error from the handler or middleware
      ---@field public handled boolean|nil `true` when the request has been handled
      ---@field public socket table Luasocket api conforming socket
    1 local Request = {}

    1 Request.__index = Request

      ---Parse the first line of an HTTP request
      ---@param line string
      ---@return table
      local function parse_preamble(line)
    7     local start, _, method, path, http_version = string.find(line, '([A-Z]+) (.+) HTTP/([0-9.]+)')
    7     assert(start, string.format('Invalid http request first line: "%s"', line))
    6     return {
    6         method = method,
    6         url = net_url.parse(path),
    6         http_version = http_version,
    6         _body = nil,
    6         _headers = nil,
    6     }
      end

      ---Get the headers for this request
      ---parsing the incoming stream of headers
      ---if not already parsed
      ---@return Headers, string|nil
    1 function Request:get_headers()
    3     if self.parsed_headers == false then
    3         local err = self:_fill_headers()
    3         if err ~= nil then
****0             return nil, err
              end
          end
    3     return self._headers
      end

      ---read from the socket filling in the headers property
    1 function Request:_fill_headers()
          while true do
   51         local done, err = self:_parse_header()
   51         if err ~= nil then
****0             return err
              end
   51         if done then
    3             self.parsed_headers = true
    3             return
              end
          end
      end

      ---Read a single line from the socket and parse it as an http header
      ---returning true when the end of the http headers
      ---@return boolean|nil, string|nil
    1 function Request:_parse_header()
   51     local line, err = self:_next_line()
   51     if err ~= nil then
****0         return nil, err
          end
   51     if self._headers == nil then
    3         self._headers = Headers.new()
          end
   51     if line == '' then
    3         return true
          else
   48         self._headers:append_chunk(line)
          end
   48     return false
      end
      ---Read a single line from the socket
      ---@return string|nil, string|nil
    1 function Request:_next_line()
   54     local line, err = self.socket:receive('*l')
   54     return line, err
      end

      ---Get the contents of this request's body
      ---if not yet received, this will read the body
      ---from the socket
      ---@return string|nil, string|nil
    1 function Request:get_body()
    1     if not self._received_body then
    1         local err = self:_fill_body()
    1         if err ~= nil then
****0             return nil, err
              end
          end
    1     return self._body
      end

      ---Read from the socket, filling the body property
      ---of this request
      ---@return string|nil
    1 function Request:_fill_body()
    2     local len, err = self:content_length()
    2     if len == nil then
****0         return err
          end
    2     self._body = self.socket:receive(len)
    2     self._received_body = true
      end

      ---Get the value from the Content-Length header that should be present
      ---for all http requests
      ---@return number|nil, string|nil
    1 function Request:content_length()
    2     local headers, err = self:get_headers()
    2     if err then
****0         return nil, err
          end
    2     if headers.content_length == nil then
****0         return 0
          end
    2     return math.tointeger(headers.content_length) or 0
      end

      ---Construct a new Request
      ---@param socket table The tcp client socket for this request
      ---@return Request|nil, string|nil
    1 function Request.new(socket)
    3     assert(socket, 'cannot create request with nil socket')
    3     local r = {
    3         socket = socket,
    3         parsed_headers = false,
          }
    3     setmetatable(r, Request)
    3     local line, acc_err = r:_next_line()
    3     if acc_err then
****0         return nil, acc_err
          end
    3     local pre, pre_err = parse_preamble(line)
    3     if pre_err then
****0         return nil, pre_err
          end
    3     r.http_version = pre.http_version
    3     r.method = pre.method
    3     r.url = pre.url
    3     return r
      end

    1 return {
    1     Request = Request,
    1     testable = {
    1         parse_preamble = parse_preamble,
    1     }
    1 }

==============================================================================
luncheon/response.lua
==============================================================================
    1 local headers = require 'luncheon.headers'
    1 local statuses = require 'luncheon.status'

      ---@class Response
      ---@field public headers Headers The HTTP headers for this response
      ---@field public body string the contents of the response body
      ---@field public outgoing table The socket this response will send on
      ---@field private should_close boolean
    1 local Response = {}
    1 Response.__index = Response

      ---Send all text provided, retrying on failure or timeout
      ---@param sock table The client socket to send on
      ---@param s string The string to send
    1 function Response._send_all(sock, s)
  515     local total_sent = 0
  515     local target = #s
  515     local retries = 0
 1041     while total_sent < target and retries < 5 do
  527         local success, sent_or_err, err = pcall(sock.send, sock, string.sub(s, total_sent))
  527         if not success then
****0             retries = retries + 1
              else
  527             if not sent_or_err then
   21                 if err == 'closed' then
    1                     return nil, 'Attempt to send on closed socket'
   20                 elseif err == 'timeout' then
   20                     retries = retries + 1
                      end
                  else
  506                 total_sent = total_sent + sent_or_err
                  end
              end
          end
  514     return total_sent
      end

      ---create a response for to a corresponding request
      ---@param outgoing table anything that can call `:send()`
      ---@param send_buffer_size number|nil If provided, sending will happen in a buffered fashion
      ---@return Response
    1 function Response.new(outgoing, send_buffer_size)
   17     local base = {
   17         headers = headers.Headers.new(),
   17         _status = 200,
   17         body = '',
   17         http_version = '1.1',
   17         outgoing = outgoing,
   17         _send_buffer_size = send_buffer_size,
   17         chunks_sent = 0,
   17         should_close = true,
          }
   17     setmetatable(base, Response)
   17     return base
      end

      ---Set the status for this request
      ---@param n number the 3 digit status
      ---@return Response
    1 function Response:status(n)
    4     if type(n) == 'string' then
    1         n = math.tointeger(n)
          end
    4     if type(n) ~= 'number' then
    1         return nil, string.format('http status must be a number, found %s', type(n))
          end 
    3     self._status = n
    3     return self
      end

      ---set the content type of the outbound request
      ---@param s string the mime type for this request
    1 function Response:content_type(s)
    9     if type(s) ~= 'string' then
****0         return nil, string.format('mime type must be a string, found %s', type(s))
          end
    9     self.headers.content_type = s
    9     return self
      end

      ---Set the Content-Length header for this response
      ---@param len number The length of the content that will be sent
      ---@return Response
    1 function Response:content_length(len)
    5     if type(len) ~= 'number' then
****0         return nil, string.format('content length must be a number, found %s', type(len))
          end
    5     self.headers.content_length = string.format('%i', len)
    5     return self
      end

      ---Set the send buffer size to enable buffered writes
      ---if unset, the full response body is buffered before sending
      ---@param size number|nil
    1 function Response:set_send_buffer_size(size)
    5     self._send_buffer_size = size
      end

      ---Serialize this full response into a string
      ---@return string
    1 function Response:_serialize()
    5     self:content_length(#self.body)
    5     return self:_generate_prebody()
    5         .. (self.body or '')
      end

      ---Generate the first line of this response without the trailing \r\n
      ---@return string
    1 function Response:_generate_preamble()
   22     return string.format('HTTP/%s %s %s',
   11         self.http_version,
   11         self._status,
   11         statuses[self._status] or ''
   11     )
      end

      ---Create the string representing the pre-body entries for
      ---this request. including the 2 trailing \r\n
      ---@return string
    1 function Response:_generate_prebody()
   11     return self:_generate_preamble() .. '\r\n'
   11         .. self.headers:serialize() .. '\r\n'
      end

      ---Append text to the body
      ---@param s string the text to append
      ---@return Response
    1 function Response:append_body(s)
  519     if type(s) == 'string' then
  519         self.body = (self.body or '') .. s
          end
  519     if self:_should_send() then
  506         local success, err = self:_send_chunk()
  506         if not success then
    1             return nil, err
              end
          end
  518     return self
      end

      ---Check if we are sending in buffered mode
      ---and if we should send the current buffer
      ---@return number|nil
    1 function Response:_should_send()
  519     return self._send_buffer_size and
  519         #self.body >= self._send_buffer_size
      end

      ---Send a chunk when sending in buffered mode
      ---this will truncate self.body to an empty string
    1 function Response:_send_chunk()
  506     local to_send = self.body
  506     if not self:has_sent() then
    6         to_send = self:_generate_prebody()..to_send
          end
  506     local num_sent, err = Response._send_all(self.outgoing, to_send)
  506     self.body = ''
  506     if num_sent == nil then
    1         return nil, err
          end
  505     return 1
      end

      ---complete this http request by sending this response as text
      ---@param s string|nil
    1 function Response:send(s)
    9     if type(s) == 'string' then
    3         self:append_body(s)
          end
    9     if self.headers.content_type == nil then
    8         self:content_type('text/plain')
          end
    9     if self._send_buffer_size == nil
    4     or not self:has_sent() then
    5         return Response._send_all(self.outgoing, self:_serialize())
          end
    4     return Response._send_all(self.outgoing, self.body)

      end

      ---Create a ltn12 sink for sending on this Response
      ---If using this interface, it is a very good idea to already
      ---know the size of your response body and set that prior
      ---to passing this sink to a pump. If the Content-Length header
      ---is unset when this starts, there will be no way to back fill
      ---that value.
      ---
      ---For buffered writes, be sure to call :set_send_buffer_size
      ---@return fun(chunk:string|nil, err: string|nil): number|nil
    1 function Response:sink()
          return function(chunk, err)
  490         assert(not err, err)
  490         if chunk == nil then
    2             self:send()
              else
  488             self:append_body(chunk)
              end
  490         return 1
          end
      end


      ---Check if this response has sent any bytes
    1 function Response:has_sent()
  516     if self._has_sent then
  499         return self._has_sent
          end
   17     local _, s = self.outgoing:getstats()
   17     self._has_sent = s > 0
   17     return self._has_sent
      end

    1 function Response:close()
****0     self.outgoing:close()
      end

    1 return {
    1     Response = Response,
    1 }

==============================================================================
luncheon/status.lua
==============================================================================
    1 return {
    1     [100] = 'Continue',
    1     [101] = 'Switching Protocols',
    1     [200] = 'OK',
    1     [201] = 'Created',
    1     [202] = 'Accepted',
    1     [203] = 'Non-Authoritative Information',
    1     [204] = 'No Content',
    1     [205] = 'Reset Content',
    1     [206] = 'Partial Content',
    1     [300] = 'Multiple Choices',
    1     [301] = 'Moved Permanently',
    1     [302] = 'Found',
    1     [303] = 'See Other',
    1     [304] = 'Not Modified',
    1     [305] = 'Use Proxy',
    1     [307] = 'Temporary Redirect',
    1     [400] = 'Bad Request',
    1     [401] = 'Unauthorized',
    1     [402] = 'Payment Required',
    1     [403] = 'Forbidden',
    1     [404] = 'Not Found',
    1     [405] = 'Method Not Allowed',
    1     [406] = 'Not Acceptable',
    1     [407] = 'Proxy Authentication Required',
    1     [408] = 'Request Timeout',
    1     [409] = 'Conflict',
    1     [410] = 'Gone',
    1     [411] = 'Length Required',
    1     [412] = 'Precondition Failed',
    1     [413] = 'Payload Too Large',
    1     [414] = 'URI Too Long',
    1     [415] = 'Unsupported Media Type',
    1     [416] = 'Range Not Satisfiable',
    1     [417] = 'Expectation Failed',
    1     [418] = 'I\'m a teapot',
    1     [426] = 'Upgrade Required',
    1     [500] = 'Internal Server Error',
    1     [501] = 'Not Implemented',
    1     [502] = 'Bad Gateway',
    1     [503] = 'Service Unavailable',
    1     [504] = 'Gateway Time-out',
    1     [505] = 'HTTP Version Not Supported',
    1     [102] = 'Processing',
    1     [207] = 'Multi-Status',
    1     [226] = 'IM Used',
    1     [308] = 'Permanent Redirect',
    1     [422] = 'Unprocessable Entity',
    1     [423] = 'Locked',
    1     [424] = 'Failed Dependency',
    1     [428] = 'Precondition Required',
    1     [429] = 'Too Many Requests',
    1     [431] = 'Request Header Fields Too Large',
    1     [451] = 'Unavailable For Legal Reasons',
    1     [506] = 'Variant Also Negotiates',
    1     [507] = 'Insufficient Storage',
    1     [511] = 'Network Authentication Required',
    1 }

==============================================================================
Summary
==============================================================================

File                  Hits Missed Coverage
------------------------------------------
luncheon/headers.lua  65   1      98.48%
luncheon/request.lua  71   9      88.75%
luncheon/response.lua 105  4      96.33%
luncheon/status.lua   58   0      100.00%
------------------------------------------
Total                 299  14     95.53%
